import java.security.MessageDigest

/*
    Password Manager: Manages accounts given by user with encrypted password.
    Copyright (C) 2022-2025  Francesco Marras (2004marras@gmail.com)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see https://www.gnu.org/licenses/gpl-3.0.html.
 */

plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    id 'java'
    id 'application'
    id 'signing'

    id 'org.openjfx.javafxplugin' version '0.1.0'
    id 'io.franzbecker.gradle-lombok' version '5.0.0'

    // https://github.com/gradlex-org/java-module-dependencies
    id 'org.gradlex.java-module-dependencies' version '1.6.4'
}

project.version = '3.1.0'

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

dependencies {
    implementation project(':lib')
}

mainModuleInfo {
    annotationProcessor 'lombok'
}

testModuleInfo {
    annotationProcessor 'lombok'
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    sourceCompatibility = JavaVersion.VERSION_25
    toolchain {
        languageVersion = JavaLanguageVersion.of(25)
    }
}

application {
    // Define the main class for the application.
    mainModule = 'password.manager.app'
    mainClass = 'password.manager.app.App'

    // JVM arguments
    applicationDefaultJvmArgs = [
        '--enable-native-access=javafx.graphics',
        '--add-exports', 'javafx.base/com.sun.javafx.event=org.controlsfx.controls'
    ]
}

testing {
    suites {
        test {
            useJUnitJupiter '5.13.4'
        }
    }
}

javafx {
    version = '25'
    modules = [ 'javafx.base', 'javafx.controls', 'javafx.fxml', 'javafx.graphics', 'javafx.web' ]
}

jar {
    archiveBaseName.set(rootProject.name)
    manifest {
        attributes 'Implementation-Title': 'Password Manager', 'Main-Class': 'password.manager.app.App'
    }
}

def gpgExists = ['gpg', 'gpg.exe'].any { executable ->
    System.getenv('PATH').split(File.pathSeparator).any { path -> new File(path, executable).exists() }
}
def gpgPropertiesExist = (project.hasProperty('signing.keyId') 
        && project.hasProperty('signing.password') 
        && project.hasProperty('signing.secretKeyRingFile'))

signing {
    if(!gpgExists) {
        println "Gpg executable not found in PATH"
    } else if(!gpgPropertiesExist) {
        println "Gpg signing properties missing"
    } else {
        println "Gpg signing enabled"
        useGpgCmd()
        sign jar
        sign distZip
        sign distTar
    }
}

def gpgSignable = gpgExists && gpgPropertiesExist

def resourceDir = layout.projectDirectory.dir('src/main/resources')
def compileDir = rootProject.layout.projectDirectory.dir('compiled')
resourceDir.asFile.mkdirs()
compileDir.asFile.mkdirs()

def distDir = compileDir.dir('distributions')
def installerDir = compileDir.dir('installers')
distDir.asFile.mkdirs()
installerDir.asFile.mkdirs()

tasks.register('assemblePortables', Delete) {
    delete distDir

    dependsOn tasks.distTar, tasks.distZip
    if(gpgSignable) {
        dependsOn tasks.signDistTar, tasks.signDistZip
    }

    doLast {
        mkdir distDir
        copy {
            from tasks.distTar
            if(gpgSignable) {
                from tasks.signDistTar
            } 
            into distDir.dir('tar')
        }
        copy {
            from tasks.distZip
            if(gpgSignable) {
                from tasks.signDistZip
            }
            into distDir.dir('zip')
        }
    }
}

tasks.register('readyAllJars', Copy) {
    dependsOn tasks.jar
    if(gpgSignable) {
        dependsOn tasks.signJar
    }
    from configurations.runtimeClasspath, tasks.jar
    if(gpgSignable) {
        from tasks.signJar
    }
    into layout.buildDirectory.dir('jars')
}

tasks.register('assembleInstallers', FullJPackageTask) {
    dependsOn tasks.readyAllJars

    aboutUrl = 'https://github.com/Achille004/PasswordManager'
    appDescription = 'Password Manager'
    appName = 'Password Manager'
    appVersion = project.version
    copyright = 'Â© Francesco Marras'
    javaOptions = ['-Dfile.encoding=UTF-8']
    licenseFile	= resourceDir.file('license.txt')
    module = 'password.manager.app/password.manager.app.App'
    modulePaths = ['build/jars']
    runtimeImage = System.getProperty('java.home')
    vendor = 'Francesco Marras'

    windows {
        icon =  resourceDir.file('icon.ico')
        destination = installerDir.dir('windows')
        winConsole = false
        winDirChooser = true
        winHelpUrl = 'https://github.com/Achille004/PasswordManager/issues'
        winMenu = true
        winMenuGroup = 'Francesco Marras'
        winShortcut = true
        winShortcutPrompt = true
    }

    mac {
        icon =  resourceDir.file('icon.icns')
        destination = installerDir.dir('mac')
        macAppCategory  = 'security'
        macAppStore = false
        macPackageIdentifier = 'PasswordManager-3.1.0'
        macPackageName = 'PasswordManager'
        macSigningKeyUserName = 'Francesco Marras'
    }

    linux {
        icon =  resourceDir.file('icon.ico')
        destination = installerDir.dir('linux')
        linuxAppCategory = 'security'
        linuxDebMaintainer = '2004marras@gmail.com'
        linuxMenuGroup = 'Francesco Marras'
        linuxRpmLicenseType = 'GPLv3'
        linuxShortcut = true
    }
}

tasks.register('dryAssembleInstallers') {
    System.setProperty("jpackage.dryRun", "true")
    finalizedBy tasks.assembleInstallers
}

tasks.register('generateChecksums') {
    def out = compileDir.file("checksums.txt").asFile
    out.parentFile.mkdirs()
    out.createNewFile()

    def digest = MessageDigest.getInstance('SHA-256')
    out.withWriter { w -> fileTree(compileDir).each { f ->
        if(!f.name.endsWith('.asc') && !f.name.endsWith('.txt')) {
            println "Generating checksum for ${f.name}"
            def sha = digest.digest(f.bytes).collect{String.format("%02x", it)}.join()
            w << "${sha}  ${f.name}\n"
        }
    }}
}

tasks.register('assembleAll') {
    dependsOn tasks.assemblePortables
    dependsOn tasks.assembleInstallers
}